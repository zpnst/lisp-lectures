;;;; Ассоциативные списки и множества - списки специального вида

(print (cons 42 nil)) ; обычная cons ячейка содержит значение и ссылку на следующую cons ячейку
(print (cons 42 42))  ; однако второе поле cons ячейки может содержать и другое значение. Такая структура удобна для созлания пары
(print '(42 . 42))    ; при записи таких пар между элементами ставится точка

;;; Tочечные пары испольщуются в Ассоциативных списках
;;; Ассоциативный список - простейшая реалищация таблицы поиска (lookup table)

(defvar *alist* 
    '((1 . "one") (2 . "two"))) ; cons ячейка, где первое поле служит для хранения ключа, а второе поле служит для хранения значения, которое ассоциированно с этим ключом

(print *alist*)

;;; Да, в Lisp есть полноценные Хэш-таблицы, но в случае с небольшим количесвтос элементов проще использовать списки точечных пар

(format t "~%")

;;; Поиск в ассоциативных списках выполняется с помощью функции assoc (время O(n))
;;; По умолчанию assoc использует для сравнения ключей предикат equal, который может сравнивать числа и символы
;;; Функция assoc возвращает первую найденную пару, ключ которой равен запрошенному ключу
(print (assoc 1 *alist*))
(print (assoc 2 *alist*))

;;; В случае когда нужно исползовать другой предикат стравнения - нужно его явно указать в ключевом параметре :test
(format t "~%")

(defvar listik
    '(("one" . 1) ("two" . 2)))

(print (assoc "two" listik)) ; NIL

(print 
    (assoc "two" listik 
        :test #'string=))

(format t "~%")

;;; Добавление пар в ассоциативный список происходит также, как и в обычный спсиок

;;; Разные способы:

(defvar ls 
    '((4 . 44) (5 . 55)))

(print ls)


(setf ls 
    (cons (cons 3 33) ls)) ; (cons<data, ptr | data>)

(print ls)

(setf ls 
    (acons 99 9 ls)) ; acons позволяет немного сократить запись, однако необходимость сохранять возвращаемое значение с помощью setf - отсаётся

(print ls)

;;; Самый просто способ - это использовать макрос push
(push (cons 2 22) ls)
(print ls)
(push '(1 . 11) ls) 
(print ls)

(nconc ls '(8 . 88))
(print ls)

(print (assoc 1 ls))

(format t "~%~%")

;;; Интересный пример

(defun print-string (settings-list)
    (dotimes (i 4)
        (if (or (= (+ i 1) 3) (= (+ i 1) 1))
            (format t "~a" (cdr (assoc (+ i 1) settings-list)))
            (format t "~a " (cdr (assoc (+ i 1) settings-list)))))
    (format t "~%"))


;;; Базовая кофигурация для печати "Hello, World!"
(defvar settings-list
    '((1 . "Hello") (2 . ",") (3 . "World") (4 . "!"))) 

(print-string settings-list) ;; результат "Hello, World!"

;;; Пользователь хочет заменить "World" на "Multiverse". Добавляем новую пару (2 . "Multiverse") в начало ассоциативного списка
(push '(3 . "Multiverse") settings-list)

;;; Теперь по ключу 2 assoc вернёт именно изменённый параметр, так как мы добавили новый параметр в начало спсика. assoc ищет первое вхождение
(format t "~a~%" (assoc 3 settings-list :test #'equalp))

(print-string settings-list) ;; теперь же результат "Hello, Multiverse!"

;;; Получается, более ранний элемент списка будет экранировать более поздний
;;; Так часто делают, когда ассоциативный список хранит настройки программы по умолчанию, которые можно менять
;;; Если пользователь в явном виде задал специфические настрйоки, то они добавляются в начало спсика и будут найдены первыми при поиске, заменяя собой настрйоки по умолчанию

;;; Функция pairlis создаёт ассоциативный спсиок, где ключами выступают жлементы первого спсика, а значениями - элемнеты второго
(defvar *list1* '("one" "two" "three"))
(print *list1*)

(defvar *list2* '(1 2 3))
(print *list2*)

(defvar *plist* (pairlis *list1* *list2*))
(print *plist*)

(print (assoc "two" *plist* :test #'string=))

(format t "~%")

;;; rassoc - обратный поиск в ассоциативном списке
(setf *ls* 
    '(("one" . 1) ("five" . 5)))

(print (rassoc 5 *ls*))

(format t "~%")

;;; Списки свойств - другая разновидность таблиц поиска на основе спсиков
;;; Это обычные спсики, где жлементы ключи чередуются с жлементами значениями

; (defvar lll '(print 1 two 2))
; (funcall (car lll) lll)

(defvar lll '(one 1 two 2)) ; количество элементов должно быть чётным
(print (getf lll 'one))
(setf (getf lll 'two) 22)
(print lll)
;;; такие спсики менее удобны чем ассоциативный список по той причине, что функция поиска getf использует предикат eq для сравнения => в качестве ключей допустимпо использовать только тип символ и getf не принимает параметров, где можно было бы явно указать кастомный предикат сравнения =(

(format t "~%")

;;; В Lisp нет отедьного типа данных под множества, однако они тоже реализуются через списки

(defvar *set* nil)
(print *set*)

;;; Функция adjoin добавляет новый элемент в множество и возвращает новное множество (то есть просто push для уникальных элементов в списке)
(setf *set* (adjoin 1 *set*))
(setf *set* (adjoin 2 *set*))

(setf *set* (adjoin 1 *set*)) ; каждый элемент уникален! повторное добавление элемента не меняет множества

(print *set*)

;;; Фцкнция adjoin может принимать предикат сравнения, который нужно использовать для проверки наличия элемента в множестве

(defvar setik nil)

(setf setik 
    (adjoin "a" setik :test #'string=))

(setf setik 
    (adjoin "b" setik :test #'string=))

(setf setik 
    (adjoin "c" setik :test #'string=))

(setf setik 
    (adjoin "c" setik :test #'string=))


(print setik) ; ("c" "b" "a")
;;; Однако без явного указания предиката сравнения было бы так ("c" "c" "b" "a"), так как это просто обычный список
(format t "~%")

;;; Для сравнения вхождения элемента в список и ледовательно в множество испольщуется функция Member

(defvar *setik* '(1 2 3 4 5))
(print (member 1 *setik*)) ; Возвращает ссылку на cons ячейку, содержащую первое вхождения указанного элемнета
(print (member 3 *setik*))
(print (member 5 *setik*))
(print (member 9 *setik*)) ; Иначе NIL

(format t "~%")

;;; Предикат subsetp используется если нужно проверить является множество подмножеством другого
(print (subsetp '(1 2 3) '(1 2 3 4 5)))
(print (subsetp '(1 2 3) '(2 3 4 5)))

(format t "~%")

;;; intersection - пересечение мноджеств
(print
    (intersection 
        '(1 2 3 4 5)
        '(2 3)))

(print 
    (intersection
        '(1 2 3 4 5)
        '(98 99 100)))

(format t "~%")

;;; union - обхединение множеств
(print 
    (union
        '(1 2 3)
        '(3 4 5 6 7)))

(format t "~%")

;;; set-difference - разность двух множеств (\)
(print 
    (set-difference
        '(1 2 3 4 5)
        '(2 3 4)))

(print 
    (set-difference
        '(2 3 4)
        '(1 2 3 4 5)))

(format t "~%")

;;; set-exclusive-or - симметрическая разность двух множеств
(print
    (set-exclusive-or
        '(1 2 3 4 5)
        '(4 5 6 7 8)))