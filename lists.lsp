;;;; Список - базовая струкутра данных в Lisp

;;; Постоянное время вставки и удаления (односвязные спсики, linked lists)

;;; Составлен из cons-ячеек (cons cells)
(print (cons 33 nil)) ; 33 -> nil, (33) 

;;; Составить спсиок в Lisp модно путём вложенных вызовов cons
(print (cons 11 (cons 22 (cons 33 nil)))) ;; 11 --> 22 --> 33 --> nil, (11 22 33) 

(format t "~%")

;;; (print (cons 33 44 nil)) ; *** - EVAL: too many arguments given to CONS: (CONS 33 44 NIL)

;;; Формы в Lisp - те же самые списки, которые трактуются Lisp'ом как команды с аргументами
;;; Чтобы указать, что это не команды с аргументами, а данные - нужно добавить специальный оператор quote
(print '(1 2 3))
(print (quote (1 2 3)))

;;; функция list принимает произвольное количество аргумнетов, из которых формирует список
(print (list 1 2 3))
(print (list))

(format t "~%")

;;; Способы записи пустого списка () = '() = nil 'nil
(print ())
(print '())
(print nil)
(print 'nil)

(format t "~%")

;;; Итак, спсиок является совокуупностью соединённых друг с другом cons ячеек
(defvar lst '(11 22 33))

(print lst)
;;; Названия команд car и cdr произошли от названий командв компьютерх IBM-704
(print (car lst)) ; голова списка - первый элемент
(print (cdr lst)) ; хвост списка - все остальные элементы

;;; Их синонимы
(print (first lst)) 
(print (rest lst))

;;; Примеры использования
(defvar fruits 
    '(banana apple orange peach))

(print fruits)

(format t "~%")

(print (car fruits))
(print (car (cdr fruits)))
(print (car (cdr (cdr fruits))))
(print (car (cdr (cdr (cdr fruits)))))

(format t "~%")

(print (caddr fruits))  ; (print (car (cdr (cdr fruits))))
(print (cadddr fruits)) ; (print (car (cdr (cdr (cdr fruits)))))

(format t "~%")

(setf lst '(((1 2) ((3) (4 5)) 6)))
(print lst)

(format t "~%")

(print (car lst))
(print (cadar lst))
(print (caddar lst))

;;; Обращение по индексам

(format t "~%")

(print (first (car lst)))
(print (second (car lst)))
(print (third (car lst)))

(format t "~%")

;;; nth работает только со списками
(print (nth 0 (car lst)))
(print (nth 1 (car lst)))
(print (nth 2 (car lst)))

(format t "~%")

;;; elt работает как со списками, так и с массивами
(print (elt (car lst) 0))
(print (elt (car lst) 1))
(print (elt (car lst) 2))

(format t "~%")

#|
 | Функциональная парадигма предпологает сведение побочных эффектов к минимуму. 
 | Присваивание значения переменным, изменеие элементов списка и его струкутры в целом - недопустимо в чистых функциональных языках 
 | В функциональьных языках функции не модифицируют струткры данных, а возвращают их обновлённые копии. 
 | Многие функции Lisp именно так себя и ведут. Однако в случае со сложными структурами данных, создание копий может стаь дорогостоящей операцией
 | Common Lisp не является читсым функциональным языком, поэтому разрешает выполнять разрушающие операции над структурами данных
 | Все фукнции выше могут быть испольщованы в комбинации с универсальным макросом setf. В частности можно изменить значение элемента в списке или поменять его структуру
 |#

(defvar listik '(11 22 33))
(print listik)

(setf (nth 1 listik) 44)
(print listik)

(setf listik '((42)(((((((42))))))(42))(((42)))))
(print listik)

(format t "~%")

;;; Рассмотрим функции, которые создают копии списков или их частей и их аналоги, которые делают  тоже самое путём модификации cons ячеек
(defvar listichek1 '(11 22))
(print listichek1)

(defvar listichek2 '(33 44))
(print listichek2)

(defvar listichek3 '(55 66))
(print listichek3)

;;; append вставояет один список в конец другого
(defvar master-listichek 
    (append listichek1 listichek2 listichek3)) ; можно передать люое количестов аргументов

#|
 | listichek1 --> 11 --> 22 --> nil
 | listichek2 --> 33 --> 44 --> nil
 | listichek3 --> 55 --> 66 --> nil
 |
 | Самое интересное, что функция append возвращает копию только перовго списка listichek1 (master-listichek = listichek1), но не стала копировать последующие списки, то есть listichek2 и listichek3
 |
 | master-listichek --> listichek2 --> listichek3
 | (11 --> 22) --> (33 --> 44) --> (55 --> 66) --> nil
 |#

(print master-listichek)

(print (append)) ; вызов append без аргументов возвращает nil

(format t "~%")

;;; nconc - разрушающий аналог функции append
;;; Изменяет значения второго поля(т.е указателя на next) послежний cons ячейки первого списка таким, что оно начинает ссылаться на первую cons ячейку второго списка
;;; Новых cons ячеек в данном случае не создаётся

(defvar llsstt1 '(1 2 3))
(defvar llsstt2 '(4 5 6))

(print llsstt1) ; (1 2 3)

(nconc llsstt1 llsstt2)

(print llsstt1) ; (1 2 3 4 5 6)

;;; llsstt1 --> llsstt2

(format t "~%")

;;; Разрушающие функции стоит использовать при работе с большими списками, когда копирование будет обхожится сликшом дорого
;;; Разрушающие фукнции отличаются от своиз обвчных аналогов буквой n в начале(например reverce и nreverce) за исключением нескольких случаев(например delete и remove)
;;; Классический пример функция delete, которая является разрушающим аналогом фукнции remove

(defvar some-list '(11 22 11 44))
(print (remove 11 some-list))
(print some-list)

(print (delete 11 some-list)) ; delete вернула ссылку на cons ячейку с числом 22 
(print some-list) ; убедиться в жтом можно, просмотрев содержимое списка после delete. cons ячейка с числом 11 осталась в начале списка
;;; =>
;;; Возвращаемое значение разрушающих функций также как и не разрушающих следует присваивать переменной, в которой должен хранится результат

(format t "~%")

;;; Добавление элементов в список

;;; Макрос push позовляет дорбавить элемент в начало списка(создаётся новая cons ячейка и добавляется в начало списка)
(setf ls '(11))
(push 22 ls)
(push 33 ls)
(print ls) 

;;; очень часто можно увеидеть такой приём:
(setf ls (nreverse ls)) ; элементы получаются их какого-то источнка и добавляются в начало списка. после этого мы используем разрушающую функцию nreverce чтобы кпорядочить элементы в порядке потспуления в список от самого первого до самого последнего
;;; Можно было бы сделать это и функцией reverce, но она бы создала копию. Старый список же удалился бы при сборке мусора, если на него не отсалось бы больше ссылок
;;; Но простая перенастрйока указателей в случае с nreverce не потребует дополниеьной памяти и выполнится быстрее! 
;;; Поэтому использование разрушающей функции тут оправдано!
(print ls)

(format t "~%")

;;; Добавление в конец списка
(setf ll '(11))
(print ll)

(print (nconc ll '(22))) ; но в данном случае возвращаемое щначение nconc можно не сохранять, так как первая cons ячейка списка не будет изменяться
(nconc ll (cons 33 nil)) ; без nil была бы ошибка: *** - EVAL: too few arguments given to CONS: (CONS 33)

(print ll) 

(format t "~%")

;;; При работе со спсиками часто используются и другие макросы
(setf llss '(11 22))
(print llss)

;;; Добавляет только тот элемент, которого ещё нет

(pushnew 22 llss)
(print llss)

(pushnew 33 llss)
(print llss)

;;; pop поззволяет извлечь элемент из списка
(print (pop llss))
(print llss)

;;; вместе макросы push и pop позволяют моделировать стек на основе списков, также как и vector-push и vector-pop позволяют это делать на основе одномерных массивов

